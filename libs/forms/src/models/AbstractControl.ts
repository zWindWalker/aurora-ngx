import { Observable } from 'rxjs';
import { EventEmitter } from '@angular/core';
import { ControlConfig } from './ControlConfig';
import { ValidationErrors, ValidatorFn } from './Validator';
import { FormGroup } from '@aurora-ngx/forms';
import { Validators } from '../utils/validators';

/**
 * Reports that a FormControl is valid, meaning that no errors exist in the input value.
 *
 * @see `status`
 */
export const VALID = 'VALID';

/**
 * Reports that a FormControl is invalid, meaning that an error exists in the input value.
 *
 * @see `status`
 */
export const INVALID = 'INVALID';

/**
 * Reports that a FormControl is pending, meaning that that async validation is occurring and
 * errors are not yet available for the input value.
 *
 * @see `markAsPending`
 * @see `status`
 */
export const PENDING = 'PENDING';

/**
 * Reports that a FormControl is disabled, meaning that the control is exempt from ancestor
 * calculations of validity or value.
 *
 * @see `markAsDisabled`
 * @see `status`
 */
export const DISABLED = 'DISABLED';

export type FormHooks = 'change' | 'blur' | 'submit';


/**
 * This is the base class for `FormControl`, `FormGroup.ts`, and `FormArray`.
 *
 * It provides some of the shared behavior that all controls and groups of controls have, like
 * running validators, calculating status, and resetting state. It also defines the properties
 * that are shared between all sub-classes, like `value`, `valid`, and `dirty`. It shouldn't be
 * instantiated directly.
 *
 *
 * @publicApi
 */

export abstract class AbstractControl {
  /**
   * The current value of the control.
   *
   * * For a `FormControl`, the current value.
   * * For a `FormGroup`, the values of enabled controls as an object with a key-value pair for each member of the group.
   * * For a `FormArray`, the values of enabled controls as an array.
   *
   */
  public readonly value: any;

  /**
   * An object containing any errors generated by failing validation or null if there are no errors.
   */
  public readonly errors: ValidationErrors | null;

  /**
   * True if the control is marked as `touched`.
   *
   * A control is marked `touched` once the user has triggered
   * a `blur` event on it.
   */
  public readonly touched: boolean = false;

  /**
   * The validation status of the control. There are four possible
   * validation status values:
   *
   * * **VALID**: This control has passed all validation checks.
   * * **INVALID**: This control has failed at least one validation check.
   * * **PENDING**: This control is in the midst of conducting a validation check.
   * * **DISABLED**: This control is exempt from validation checks.
   *
   * These status values are mutually exclusive, so a control cannot be both valid AND invalid or invalid AND disabled.
   */
  public readonly status: string;

  private _parent: FormGroup;

  private _asyncValidationSubscription: any;

  public validator: ValidatorFn | null;

  public _controlConfig: ControlConfig;

  /**
   * A multicasting observable that emits an event every time the value of the control changes, in
   * the UI or programmatically.
   */
  public readonly value_changes: Observable<any>;

  /**
   * A control is `enabled` as long as its `status` is not `DISABLED`.
   *
   * @see `status`
   *
   * @returns True if the control has any status other than 'DISABLED',
   * false if the status is 'DISABLED'.
   *
   */
  get enabled(): boolean {
    return this.status !== DISABLED;
  }

  /**
   * A control is `disabled` when its `status` is `DISABLED`.
   *
   * @see `status`
   *
   * Disabled controls are exempt from validation checks and
   * are not included in the aggregate value of their ancestor
   * controls.
   *
   * @returns True if the control is disabled, false otherwise.
   */
  get disabled(): boolean {
    return this.status === DISABLED;
  }

  /**
   * A control is `valid` when its `status` is `VALID`.
   *
   * @see `status`
   *
   * @returns True if the control has passed all of its validation tests,
   * false otherwise.
   */
  get valid(): boolean {
    return this.status === VALID;
  }

  /**
   * A control is `invalid` when its `status` is `INVALID`.
   *
   * @see `status`
   *
   * @returns True if this control has failed one or more of its validation checks,
   * false otherwise.
   */
  get invalid(): boolean {
    return this.status === INVALID;
  }

  /**
   * A control is `pending` when its `status` is `PENDING`.
   *
   * @see `status`
   *
   * @returns True if this control is in the process of conducting a validation check,
   * false otherwise.
   */
  get pending(): boolean {
    return this.status === PENDING;
  }

  coerceToValidator = (raw_validators: ValidatorFn | ValidatorFn[] | null): ValidatorFn | null => {

    const validator = raw_validators as ValidatorFn | null;

    return Array.isArray(raw_validators) ? this.composeValidators(raw_validators) : validator || null;

  };

  composeValidators = (validators: ValidatorFn[]): ValidatorFn | null => {
    return validators != null ? Validators.compose(validators) : null;
  };


  /**
   * Recalculates the value and validation status of the control.
   *
   * By default, it also updates the value and validity of its ancestors.
   *
   * @param opts Configuration options determine how the control propagates changes and emits events
   * after updates and validity checks are applied.
   * * `onlySelf`: When true, only update this control. When false or not supplied,
   * update all direct ancestors. Default is false..
   * * `emitEvent`: When true or not supplied (the default), emit the `valueChanges` event
   * observables emit events with the latest status and value when the control is updated.
   * When false, no events are emitted.
   */
  updateValueAndValidity(opts: { onlySelf?: boolean, emitEvent?: boolean } = {}): void {
    this._updateValue();

    if (this.enabled) {
      this._cancelExistingSubscription();
      (this as { errors: ValidationErrors | null }).errors = this._runValidator();
      // (this as { status: string }).status = this._calculateStatus();

      // if (this.status === VALID || this.status === PENDING) {
      //   this._runAsyncValidator(opts.emitEvent);
      // }
    }

    if (opts.emitEvent !== false) {
      (this.value_changes as EventEmitter<any>).emit(this.value);
    }

  }

  private _runValidator(): ValidationErrors | null {
    return this.validator ? this.validator(this) : null;
  }

  private _cancelExistingSubscription(): void {
    if (this._asyncValidationSubscription) {
      this._asyncValidationSubscription.unsubscribe();
    }
  }

  /** @internal */
  _initObservables() {
    (this as { value_changes: Observable<any> }).value_changes = new EventEmitter();
  }

  /** @internal */
  _updateValue(): void {

  }


  /**
   * Sets the value of the control. Abstract method (implemented in sub-classes).
   */
  abstract setValue(value: any, options?: Object): void;

  /**
   * Patches the value of the control. Abstract method (implemented in sub-classes).
   */
  abstract patchValue(value: any, options?: Object): void;

  /**
   * Resets the control. Abstract method (implemented in sub-classes).
   */
  abstract reset(value?: any, options?: Object): void;
}

